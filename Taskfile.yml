version: '3'

env:
 GIHUB_PAGES_URL: toshy.github.io/bunnynet-openapi-specification

tasks:
  default:
    cmds:
      - task --list

  # OpenAPI specs
  openapi:specs:
    desc: Download open api specs
    summary: |
      Requires JQ 1.7.1+
    silent: true
    shell: bash
    cmds:
      - |
        out_dir="./data"
        mkdir -p "$out_dir"
        
        manifest_path="$out_dir/manifest.json"
        declare -A existing_hashes
        if [ -f "$manifest_path" ]; then
          manifest_json=$(cat "$manifest_path")
          while IFS= read -r file; do
            hash=$(echo "$manifest_json" | jq -r --arg file "$file" '.[] | select(.fileName == $file) | .fileSha256')            
            existing_hashes["$file"]="$hash"
          done < <(echo "$manifest_json" | jq -r '.[].fileName')
        fi
        
        manifest_entries="[]"
        temp_html="$(mktemp)"
        if ! wget --quiet --retry-connrefused --waitretry=3 --read-timeout=20 --timeout=15 --tries=5 --retry-on-http-error=429,500,502,503,504 -O "$temp_html" "https://docs.bunny.net/openapi"; then
          echo "Failed to fetch OpenAPI index from bunny.net"
          exit 1
        fi

        # Extract API links from new HTML structure
        grep -oP '<a[^>]*href="([^"]+)"[^>]*>([^<]+)</a>' "$temp_html" | \
        grep -E '(Core Platform API|Origin Errors API|Storage API|Stream API|Shield API|Edge Scripting API)' | \
        while IFS=$'\n' read -r line; do
          href=$(echo "$line" | grep -oP 'href="\K[^"]+')
          text=$(echo "$line" | grep -oP '>[^<]+</a>' | sed 's/>//;s/<\/a>//')
          lower_text=$(echo "$text" | tr '[:upper:]' '[:lower:]')

          # Normalize base filename based on link text
          base_filename=""
          case "$lower_text" in
            *"core platform api"*) base_filename="core-api" ;;
            *"origin errors api"*) base_filename="origin-errors-api" ;;
            *"storage api"*) base_filename="edge-storage-api" ;;
            *"stream api"*) base_filename="stream-api" ;;
            *"shield api"*) base_filename="shield-api" ;;
            *"edge scripting api"*) base_filename="edge-scripting-api" ;;
            *)
              base_filename="$(echo "$text" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed 's/^-//;s/-$//')"
              ;;
          esac

          if [[ "$base_filename" == *"-json" ]]; then
            base_filename="${base_filename%-json}"
          fi

          # Construct full URL: use href as-is if absolute, otherwise prepend base URL
          if [[ "$href" =~ ^https?:// ]]; then
            full_url="$href"
          else
            full_url="https://docs.bunny.net$href"
          fi

          tempfile="$(mktemp)"

          echo "Downloading '$text' from '$full_url'..."
          if ! wget --quiet --retry-connrefused --waitretry=3 --read-timeout=20 --timeout=15 --tries=5 --retry-on-http-error=429,500,502,503,504 -O "$tempfile" "$full_url"; then
            echo "Failed to download $text from $full_url after retries"
            rm -f "$tempfile"
            continue
          fi

          if ! jq --indent 2 . "$tempfile" > "$tempfile.json" 2>/dev/null; then
            echo "Invalid JSON from $full_url"
            rm -f "$tempfile" "$tempfile.json"
            continue
          fi

          mv "$tempfile.json" "$tempfile"

          # Extract version from the OpenAPI spec
          api_version=$(jq -r '.info.version // "1.0.0"' "$tempfile")

          # Strip any leading 'v' from version
          api_version="${api_version#v}"

          # Convert to semver format if needed (e.g., "1" -> "1.0.0", "1.2" -> "1.2.0")
          if [[ "$api_version" =~ ^[0-9]+$ ]]; then
            # Only major version (e.g., "1")
            api_version="${api_version}.0.0"
          elif [[ "$api_version" =~ ^[0-9]+\.[0-9]+$ ]]; then
            # Major.minor (e.g., "1.2")
            api_version="${api_version}.0"
          fi

          # Construct final filename with version
          filename="${base_filename}-v${api_version}.json"
          filepath="$out_dir/$filename"

          new_hash=$(sha256sum "$tempfile" | awk '{print $1}')
          old_hash="${existing_hashes[$filename]}"

          if [ "$new_hash" = "$old_hash" ]; then
            echo "File '$filename' unchanged (checksum match); skipping overwrite."
            rm "$tempfile"
          else
            echo "File '$filename' changed or new (old: $old_hash; new: $new_hash); writing."
            mv "$tempfile" "$filepath"
          fi

          # Append entry using jq
          manifest_entries=$(echo "$manifest_entries" | jq \
            --arg source "$full_url" \
            --arg sourceDescription "$text" \
            --arg fileName "$filename" \
            --arg fileUrl "https://${GIHUB_PAGES_URL}/$filename" \
            --arg fileSha256 "$new_hash" \
            '. + [{
              source: $source,
              sourceDescription: $sourceDescription,
              fileName: $fileName,
              fileUrl: $fileUrl,
              fileSha256: $fileSha256
            }]'
          )
        done
        
        # Save manifest to file
        echo "$manifest_entries" > "$out_dir/manifest.json"